% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/metropolis.R
\name{metropolis}
\alias{metropolis}
\alias{rawMetropolis}
\title{The Metropolis Algorithm}
\usage{
metropolis(init, moves, iter = 1000, burn = 0, thin = 1,
  dist = c("hypergeometric", "uniform"), engine = c("Cpp", "R"))

rawMetropolis(init, moves, iter = 1000, dist = "hypergeometric")
}
\arguments{
\item{init}{the initial step}

\item{moves}{the moves to be used (the negatives will be added); 
they are arranged as the columns of a matrix.}

\item{iter}{number of chain iterations}

\item{burn}{burn-in}

\item{thin}{thinning}

\item{dist}{steady-state distribution; "hypergeometric" (default)
or "uniform"}

\item{engine}{C++ or R? (C++ yields roughly a 20-25x speedup)}
}
\value{
a list
}
\description{
Given a starting table (as a vector) and a collection of moves, 
run the Metropolis-Hastings algorithm starting with the starting 
table.
}
\details{
See Algorithm 1.1.13 in LAS, the reference below.
}
\examples{

\dontrun{

library(ggplot2); theme_set(theme_bw())

# move up and down integer points on the line y = 100 - x
# sampling from the hypergeometric distribution
init <- c(10,90)
moves <- matrix(c(1,-1), ncol = 1)
out <- metropolis(init, moves)
qplot(out$steps[1,])

# view convergence through trace plot
qplot(1:1000, out$steps[1,])

# sampling from the hypergeometric distribution
out <- metropolis(init, moves, dist = "uniform")
qplot(out$steps[1,])

# view convergence through trace plot
qplot(1:1000, out$steps[1,])

# look at autocorrelation
acf(out$steps[1,])
# thin
out <- metropolis(init, moves, dist = "uniform", thin = 2500)
acf(out$steps[1,])
qplot(out$steps[1,])


















data(handy)

exp   <- loglin(handy, as.list(1:2), fit = TRUE)$fit
e <- unname(tab2vec(exp))
h <- t(t(unname(tab2vec(handy))))
chisq <- algstat:::computeX2sCpp(h, e)

out <- loglinear(~ Gender + Handedness, data = handy)
chisqs <- algstat:::computeX2sCpp(out$steps, e)

mean(chisqs >= chisq)
fisher.test(handy)$p.value





A <- hmat(c(2,2), as.list(1:2))
moves <- markov(A)
outC <- metropolis(tab2vec(handy), moves, 1e4, engine = "Cpp")
str(outC)
outR <- metropolis(tab2vec(handy), moves, 1e4, engine = "R", thin = 20)
str(outR)

# showSteps(out$steps)


library(microbenchmark)
microbenchmark(
  metropolis(tab2vec(handy), moves, engine = "Cpp"),
  metropolis(tab2vec(handy), moves, engine = "R")
)

# cpp ~ 20-25x faster













showSteps <- function(steps){
  apply(steps, 2, function(x){
    x <- format(x)
    tab <- vec2tab(x, dim(handy))
    message(
      paste(
        apply(tab, 1, paste, collapse = " "),
        collapse = " "
      )
    )
    message("
", appendLF = F)
  })
  invisible()
}
# showSteps(out$steps)








}


}
\references{
Drton, M., B. Sturmfels, and S. Sullivant (2009). 
  \emph{Lectures on Algebraic Statistics}, Basel: Birkhauser 
  Verlag AG.
}
\author{
David Kahle
}
